# ret2csu

## Scenario

- Lack of useful gadgets in the binary

## Disassembly

```
...
400680:   4c 89 fa                mov    rdx,r15
400683:   4c 89 f6                mov    rsi,r14
400686:   44 89 ef                mov    edi,r13d
400689:   41 ff 14 dc             call   QWORD PTR [r12+rbx*8]
40068d:   48 83 c3 01             add    rbx,0x1
400691:   48 39 dd                cmp    rbp,rbx
400694:   75 ea                   jne    400680 <__libc_csu_init+0x40>
400696:   48 83 c4 08             add    rsp,0x8
40069a:   5b                      pop    rbx 
40069b:   5d                      pop    rbp 
40069c:   41 5c                   pop    r12
40069e:   41 5d                   pop    r13
4006a0:   41 5e                   pop    r14
4006a2:   41 5f                   pop    r15
4006a4:   c3                      ret
```

## Method

- First return to `0x40069a` to set up registers. Then, return to `0x400680` to invoke any functions
- e.g. If you want to call `func(arg0, arg1, arg2)`
    - Set `r13` to `arg0`, `r14` to `arg1`, and `r15` to `arg2`
    - Set `rbx` = 0 and `rbp` = 1 to bypass `0x40068d` ~ `0x400694`
    - Set `r12` to an address that contains the address of `foo`

> **NOTE**
> Note that the assembly is `call QWORD PTR [r12+rbx*8]`, not `call r12+rbx*8`. In other words, the program will head to `r12+rbx*8`, grab its value, and call that value. This mean that you need to find a memory address that contains the address of `func`.

## Stack Layout

| Original stack layout | Overwritten stack layout |
| :-: | :-: |
| `local variable` | `local variable` |
| `overflowed buffer` | **`0x41414141`** |
| `overflowed buffer` | **`0x41414141`** |
| `old stack frame` | **`0x41414141`** |
| `return address` | **`pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret`** |
| ... | **`0`** |
| ... | **`1`** |
| ... | **`&func`** |
| ... | **`arg0`** |
| ... | **`arg1`** |
| ... | **`arg2`** |
| ... | **`mov rdx, r15; mov rsi, r14 ; mov edi, r13d ; call QWORD PTR [r12 + rbx * 8] ; ...`** |
| ... | ... |

## Caveats

- `rdi` cannot be fully controled; only `edi` is controllable.
    - Solutions
        - If `rdi` is a pointer, you can find a writable area with an address less than 0x100000000 and write the value there.
- Difficult to find `&function`
    - Solutions
        - Make use of GOT addresses (provided that the binary is Partial-RELRO)
        - Find a predictable address and write the function pointer that you want to call there.
- No syscall gadget & No libc leak
    - Solutions
        - Some libc addresses will be retained in the stack when a libc function is called. You can make use of them.
            - e.g. By calling `gets` multiple times, there's a high chance that `_IO_file_write` will be left on the stack, and `_IO_file_write` can be used to leak libc addresses.
