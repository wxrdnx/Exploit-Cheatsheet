#define _GNU_SOURCE
#include <assert.h>
#include <fcntl.h>
#include <inttypes.h>
#include <linux/userfaultfd.h>
#include <poll.h>
#include <pthread.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <unistd.h>

uint64_t page_size;
uint64_t page_num;

long uffd;
struct uffdio_api uffdio_api;
struct uffdio_register uffdio_register;
pthread_t thr;

void *fault_handler_thread() {
    static int fault_cnt = 0;
    static void *page = NULL;
    static struct uffd_msg msg;
    struct uffdio_copy uffdio_copy;
    
    static int phase = 0;

    if (page == NULL) {
        page = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        assert(page != MAP_FAILED);
    }

    int res;
    while (1) {
        struct pollfd pollfd;
        
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        int nready = poll(&pollfd, 1, -1);
        assert(nready != -1);
        
        ssize_t nread = read(uffd, &msg, sizeof(msg));
        assert(nread > 0);

        assert(msg.event == UFFD_EVENT_PAGEFAULT);

        /* Exploit */
        /*
            void *data_ptr = malloc(PAGE_SIZE);
            *(long *)(data_ptr) = 0xdeadbeef;
            uffdio_copy.src = (unsigned long)data_ptr;
            uffdio_copy.dst = (unsigned long)msg.arg.pagefault.address & ~(page_size - 1);
            uffdio_copy.len = page_size;
            uffdio_copy.mode = 0;
            uffdio_copy.copy = 0;
            res = ioctl(uffd, UFFDIO_COPY, &uffdio_copy);
            assert(res != -1);
        */

        struct uffdio_range range;
        range.start = msg.arg.pagefault.address & ~(page_size - 1);
        range.len = page_size;
        res = ioctl(uffd, UFFDIO_UNREGISTER, &range);
        assert(res != -1);
        res = ioctl(uffd, UFFDIO_WAKE, &range);
        assert(res != -1);
    }
}

int main() {
    
    page_size = sysconf(_SC_PAGE_SIZE);
    page_num = 4;
    
    int res;
    
    /* Create an userfaultfd object */
    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    assert(uffd != -1L);
    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    res = ioctl(uffd, UFFDIO_API, &uffdio_api);
    assert(res != -1);

    /* Allocate a mmaped region for userfaultfd */
    void *uffd_addr = mmap(NULL, page_size * page_num, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    assert(uffd_addr != MAP_FAILED);
    printf("[*] mmap address: %p\n", uffd_addr);

    /* Register memory for the userfaultfd object */
    uffdio_register.range.start = (uint64_t)uffd_addr;
    uffdio_register.range.len = page_size * page_num;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    res = ioctl(uffd, UFFDIO_REGISTER, &uffdio_register);
    assert(res != -1);
    res = pthread_create(&thr, NULL, fault_handler_thread, NULL);
    assert(res == 0);

    /* Exploit */

    return 0;
}
