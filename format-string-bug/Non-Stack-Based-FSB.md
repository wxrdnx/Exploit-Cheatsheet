# Non-Stack-Based FSB

## Requirement

`printf(buff)`, where `buff` is ***NOT*** a stack local variable. This means that you can't put the address to read/write on the stack easily.

## Doubly-linked Stack Address

You can write any value onto the stack through doubly-linked stack addresses. **Doubly-linked stack addressese** consists of at least three stack addresses `chain1`, `chain2`, `chain3` such that `chain1` points to `chain2` and `chain2` points to `chain3`.

### Algorithm

Suppose that you want to write the byte `val` onto an address `addr`.

1. For `i` from 0 to 7
    1. Use FSB bug to write `chain3 + i` to `chain2` via `chain1`
        - In most cases, unless there is an overflow, only the last byte of `chain2` needs to be changed.
    2. Use FSB bug to write the `i`'th byte of `addr` to `chain3` via `chain2`
2. Now `addr` appears on the stack. You can then use FSB to write `val` to `addr`.

### Example

Using the `telescope` command in `pwndbg`, you can see that `0x7fffffffdca0` points to `0x7fffffffdd90` which is a stack address. Simultaneously, `0x7fffffffdd90` points to `0x7fffffffdd98`, which is also a stack address.

![](https://i.imgur.com/xaAmoG6.png)

Through trial and error, we know that `0x7fffffffdca0` is the 8th argument, `0x7fffffffdd90` is the 38th, and `0x7fffffffdd98` is the 39th.

The following code implements the above algorithm

```python
chain1, arg1 = 0x7fffffffdca0, 8
chain2, arg2 = 0x7fffffffdd90, 38
chain3, arg3 = 0x7fffffffdd98, 39

addr = 0x555555558000
val = 0xcc

for i in range(8):
    io.send('%{}c%{}$hhn'.format((chain3 + i) & 0xff, arg1).encode())
    io.send('%{}c%{}$hhn'.format((addr >> (i * 8)) & 0xff, arg2).encode())
io.send('%{}c%{}$hhn'.format(val, arg3).encode())
```

## Reference

- Format String exploits â€” when the buffer is not on the stack <https://anee.me/format-string-exploits-when-buffer-is-not-on-the-stack-f7c83e1a6781>
