# Format String Bug (FSB)

## Scenario

- `printf` uses user-supplied values.
- e.g. `printf(buff)`, where `buff` is user-controllable.

## Idea

- `printf` expects as many arguments as format string specifiers.
    - e.g. `printf("%d %d %d")` expects three arguments.
- If `printf` uses a user-supplied value, the number of format string specifiers can be determined by the attacker, allowing the attacker to read (or even write) values from / to the memory.
- Vulnerable Functions
    - `printf`
    - `fprintf`
    - `sprintf`
    - `snprintf`
    - `vfprintf`
    - `vprintf`
    - `vsprintf`
    - `vsnprintf`
    - `setproctitle`
    - `syslog`

## Vulnerabe Program

- Vulnerable code
    ```c
    #include <stdio.h>
    #include <unistd.h>
    int main() {
        char buf[0x100];
        read(STDIN_FILENO, buf, sizeof(buf));
        printf(buf);
    }
    ```
- Compile and run it
    ```
    $ gcc vuln.c -o vuln
    $ ./vuln
    %p.%p.%p.%p.%p.%p.%p.%p
    0x7ffc9dea6cb0.0x100.0x7f0dbc7b5931.(nil).0x7f0dbc8ced70.0x70252e70252e7025.0x252e70252e70252e.0xa70252e70252e70
    ```
    - After `printf` sees `%p`, it will start poping arguments (from `rsi`, `rdx`, `rcx`, `r8`, `r9`, stack)
    - Since no arguments is passed directly to `printf`, it will eventually *start popping values off the stack*, leading to stack-based memory leak.
    - In this case,
        - `rsi` = `0x7ffc9dea6cb0`
        - `rdx` = `0x100`
        - `rcx` = `0x7f0dbc7b5931`
        - `r8` = `0x0` (NULL)
        - `r9` = `0x7f0dbc8ced70`
        - `[rsp]` = `0x70252e70252e7025` (`"%p.%p.%p"`)
        - `[rsp + 0x8]` = `0x252e70252e70252e` (`".%p.%p.%"`)
        - `[rsp + 0x10]` = `0xa70252e70252e70` (`"p.%p.%p\n"`)

## Format string syntax

### General format

```
%[$][flags][width][.precision][length modifier]conversion
```

#### Conversions

| Specifier | Output |
| :-: | :-: |
| `%%` | write a `%` character |
| `%c` | character |
| `%s` | string |
| `%d` or `%i` | signed decimal |
| `%o` | unsigned octal |
| `%x` | unsigned hexadecimal (lowercase) |
| `%X` | unsigned hexadecimal (uppercase) |
| `%u` | unsigned decimal |
| `%f` | decimal floating point (lowercase) |
| `%F` | decimal floating point (uppercase) |
| `%e` | scientific notation (lowercase) |
| `%E` | scientific notation (uppercase) |
| `%a` | hexadecimal floating piont |
| `%A` | hexadecimal floating point |
| `%g` | `%e` or `%f`, depending on the value and precision |
| `%G` | `%E` or `%F`, depending on the value and precision |
| `%n` | number of bytes written |
| `%p` | pointer address |

#### Length Modifiers

| Modifier | Output | 
| :-: | :-: |
| `hh` | Converts to char |
| `h` | Converts to short |
| `l` | Converts to long |
| `ll` | Converts to long long |
| `L` | Converts to long double |

#### Other Useful Modifiers
    
- `$`
    - Allows you to read an argument at a specific position
    - In other words, `$` allows you to read / write to a specific memory address on the stack
    - e.g. `%12$p` prints the pointer address of the twelfth argument
- Width modifiers
    - If the value has fewer characters than `width`, it will be padded with `' '` from the left.
    - e.g. `%31c%17$hhn`
        - `%31c`
            - prints the first argument as a character
            - The width is 31, but only one character is printed â†’ A total of 31 characters is written
        - `%17$hhn`
            - Write the number of characters currently written so far (31 characters) as `char` to the seventeenth argument


> [!NOTE]
> Flags and precision is not important for FSB, consult printf's man page for more information

## Attack Methods

### DoS

In C, accessing an illegal memory will make the program crash with a Segmentation Fault. Since `%s` display (and thus will access) the string at an address supplied on the stack. If the value on the stack is not a valid address, `printf` will try to access an invalid memory, causing the program to crash with a Segmentation Fault.

```c
printf("%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s");
```