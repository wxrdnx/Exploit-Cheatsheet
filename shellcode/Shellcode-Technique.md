# Shellcoding techniques

## NOP sled

- NOP instructions do exactly nothing. In other words, all they do is run the next instruction.
- If you fill your shellcode with `nop`s on the left, it will keep doing nothing until it reaches your actual payload.
    - This gives us a larger margin of error when calculating the shellcode address.
- Some NOP instructions
    - x86 / x64
        - `nop` (1 byte)
        - `fnop` (2 bytes)
        - `xchg rax, rax` (2 bytes)
        - `push rax ; pop rax` (2 bytes)
        - `mov rax, rax` (3 bytes)
        - `inc eax ; dec eax` (4 bytes)
        - ...

## Null byte prevention

- `xor rax, rax`: zero out `rax`, no null byte opcode
- Use existing values from registers/stack
    - e.g. if initially `rdi` is already 0, `xor rdi, rdi` becomes redundant.
- `mov rax, 0x30` → `push 0x30; pop rax`
- `push 0x697a0002` → `push word 0x697a; push word 0x2`
- `mov rax, [fs:0x0]` → `xor ecx, ecx ; mov rax, [fs:rcx]`

## Shorten opcode

- `cdq` (1 byte): zero out `rdx` if `rax >= 0`
- `imul esi` (2 bytes): zero out `rdx` if `rsi == 0`
- `lodsd` (1 byte)
    - `mov eax, [esi]` (2 bytes) → `lodsd` (1 byte)
    - `mov eax, [esi + ecx - 4] (3 bytes) → `lodsd` (1 byte)
- `push rax` 16 times →
   ```
   push 0x10
   pop ecx
   repeat:
       push rax
       loop repeat
   ```
- `push 0x30; pop rax` (3 bytes) → `mov al, 0x30`
- `add eax, 1` (3 bytes), `inc rax` (3 bytes) → `inc eax` (2 bytes), `add al, 1` (2 bytes)
- `mov ecx, eax` (3 bytes), and `eax` is disposable → `xchg eax, ecx` (2 bytes)

## Caveats

- if `eax == 0x000000ff`, then after `add al, 1`, `eax == 0x00000000`
    - use `inc ax`, `inc eax`, `inc rax` instead if you want `eax == 0x00000100`
- `mov [m64], imm64` is not possible
    - e.g., `mov [rax], 0x68732f2f6e69622f` is not possible. Change it to `mov rbx, 0x68732f2f6e69622f; mov [rax], rbx`

